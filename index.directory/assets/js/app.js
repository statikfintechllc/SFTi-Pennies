/**
 * SFTi-Pennies Trading Journal - Main Application
 * Handles trade form calculations, submission, and homepage interactions
 */

// Use utilities from global SFTiUtils
class TradingJournal {
  constructor() {
    this.auth = new GitHubAuth();
    this.uploadedImages = [];
    // Get base path from URL to make code portable
    this.basePath = SFTiUtils.getBasePath();
    this.eventBus = window.SFTiEventBus;
    this.initializeApp();
  }
  
  // getBasePath is now imported from utils.js
  
  /**
   * Calculate year and week number from date (ISO week)
   * @param {Date} date - Date object
   * @returns {string} - Year and week in format "YYYY.WW"
   */
  getYearWeekNumber(date) {
    return SFTiUtils.getYearWeekNumber(date);
  }
  
  /**
   * Get trade count for a specific date
   * @param {string} dateStr - Date in MM:DD:YYYY format
   * @returns {Promise<number>} - Next trade number for that date
   */
  async getTradeCountForDate(dateStr) {
    // For now, we'll extract from the trade_number field
    // In future, this could query existing trades for the date
    const tradeNumber = document.getElementById('trade_number')?.value || '1';
    return tradeNumber;
  }
  
  /**
   * Format date as MM:DD:YYYY
   * @param {string} dateStr - Date in YYYY-MM-DD format
   * @returns {string} - Date in MM:DD:YYYY format
   */
  formatDateForFilename(dateStr) {
    return SFTiUtils.formatDateForFilename(dateStr);
  }
  
  /**
   * Initialize the application
   */
  initializeApp() {
    // Set up navigation
    this.setupNavigation();
    
    // Set up event listeners
    this.setupEventListeners();
    
    // Load trades on homepage
    if (document.getElementById('recent-trades')) {
      this.loadRecentTrades();
    }
    
    // Set up trade form if on add-trade page
    if (document.getElementById('trade-form')) {
      this.setupTradeForm();
    }
    
    // Set up auth UI
    this.setupAuthUI();
  }
  
  /**
   * Setup event listeners for reactive updates
   */
  setupEventListeners() {
    if (!this.eventBus) return;
    
    // Listen for account balance changes
    this.eventBus.on('account:balance-updated', () => {
      console.log('[TradingJournal] Account balance updated, refreshing stats');
      this.refreshStats();
    });
    
    // Listen for deposit additions
    this.eventBus.on('account:deposit-added', () => {
      console.log('[TradingJournal] Deposit added, refreshing stats');
      this.refreshStats();
    });
    
    // Listen for trades updates
    this.eventBus.on('trades:updated', () => {
      console.log('[TradingJournal] Trades updated, refreshing stats');
      this.refreshStats();
    });
    
    // Listen for analytics updates
    this.eventBus.on('analytics:updated', () => {
      console.log('[TradingJournal] Analytics updated, refreshing display');
      this.refreshStats();
    });
  }
  
  /**
   * Refresh stats without reloading trades
   */
  async refreshStats() {
    try {
      // Load latest trades data
      const response = await fetch(`${this.basePath}/index.directory/trades-index.json`);
      if (!response.ok) return;
      
      const data = await response.json();
      
      // Load analytics
      let analyticsData = null;
      try {
        const analyticsResponse = await fetch(`${this.basePath}/index.directory/assets/charts/analytics-data.json`);
        if (analyticsResponse.ok) {
          analyticsData = await analyticsResponse.json();
        }
      } catch (err) {
        console.warn('Could not load analytics data:', err);
      }
      
      // Update stats
      this.updateStats(data.statistics || {}, analyticsData);
      
    } catch (error) {
      console.warn('Could not refresh stats:', error);
    }
  }
  
  /**
   * Set up responsive navigation
   */
  setupNavigation() {
    const navToggle = document.querySelector('.nav-toggle');
    const navMenu = document.querySelector('.nav-menu');
    
    // Check if navbar was dynamically generated by navbar.js
    // If it has the navbar-floating class, it's being handled by navbar.js
    const navbar = document.querySelector('nav.navbar');
    const isDynamicNavbar = navbar && navbar.classList.contains('navbar-floating');
    
    if (navToggle && navMenu) {
      // Toggle mobile menu
      navToggle.addEventListener('click', () => {
        navToggle.classList.toggle('active');
        navMenu.classList.toggle('active');
      });
      
      // Only setup dropdown handlers if not using dynamic navbar
      // The dynamic navbar (navbar.js) handles its own dropdowns
      if (!isDynamicNavbar) {
        // Handle submenu toggles on all screen sizes
        document.querySelectorAll('.nav-item.has-submenu').forEach(item => {
          const link = item.querySelector('.nav-link');
          
          if (link) {
            link.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              
              // Close other submenus
              document.querySelectorAll('.nav-item.has-submenu').forEach(otherItem => {
                if (otherItem !== item) {
                  otherItem.classList.remove('active');
                }
              });
              
              // Toggle this submenu
              item.classList.toggle('active');
            });
          }
        });
      }
      
      // Close menu when clicking outside
      document.addEventListener('click', (e) => {
        if (!navMenu.contains(e.target) && !navToggle.contains(e.target)) {
          navToggle.classList.remove('active');
          navMenu.classList.remove('active');
          document.querySelectorAll('.nav-item.has-submenu').forEach(item => {
            item.classList.remove('active');
          });
        }
      });
      
      // Close submenus when clicking on submenu items
      document.querySelectorAll('.nav-submenu .nav-link').forEach(link => {
        link.addEventListener('click', () => {
          // Close all submenus
          document.querySelectorAll('.nav-item.has-submenu').forEach(item => {
            item.classList.remove('active');
          });
          // Close mobile menu if open
          if (window.innerWidth <= 768) {
            navToggle.classList.remove('active');
            navMenu.classList.remove('active');
          }
        });
      });
    }
  }
  
  /**
   * Set up authentication UI elements
   */
  setupAuthUI() {
    const authButton = document.getElementById('auth-button');
    if (authButton) {
      if (this.auth.isAuthenticated()) {
        authButton.textContent = 'Logout';
        authButton.addEventListener('click', () => {
          this.auth.clearAuth();
          window.location.reload();
        });
      } else {
        authButton.textContent = 'Login';
        authButton.addEventListener('click', () => {
          showAuthPrompt();
        });
      }
    }
  }
  
  /**
   * Load and display recent trades
   */
  async loadRecentTrades() {
    const container = document.getElementById('recent-trades');
    if (!container) return;
    
    try {
      // Try to fetch trades index using dynamic base path
      const response = await fetch(`${this.basePath}/index.directory/trades-index.json`);
      if (!response.ok) {
        throw new Error('Trades index not found');
      }
      
      const data = await response.json();
      const trades = data.trades || [];
      
      // Sort by date and get 3 most recent
      const recentTrades = trades
        .sort((a, b) => new Date(b.entry_date) - new Date(a.entry_date))
        .slice(0, 3);
      
      // Display trades
      container.innerHTML = recentTrades.map((trade, index) => 
        this.createTradeCard(trade, index)
      ).join('');
      
      // Load analytics for percentage returns
      let analyticsData = null;
      try {
        const analyticsResponse = await fetch(`${this.basePath}/index.directory/assets/charts/analytics-data.json`);
        if (analyticsResponse.ok) {
          analyticsData = await analyticsResponse.json();
        }
      } catch (err) {
        console.warn('Could not load analytics data:', err);
      }
      
      // Update stats with analytics data
      this.updateStats(data.statistics || {}, analyticsData);
      
    } catch (error) {
      console.warn('Could not load trades:', error);
      container.innerHTML = `
        <div class="alert alert-warning">
          <p>No trades found yet. <a href="index.directory/add-trade.html">Add your first trade!</a></p>
        </div>
      `;
    }
  }
  
  /**
   * Create HTML for a trade card
   * @param {Object} trade - Trade data
   * @param {number} index - Card index for animation delay
   * @returns {string} HTML string
   */
  createTradeCard(trade, index = 0) {
    const pnl = parseFloat(trade.pnl_usd || 0);
    const pnlPercent = parseFloat(trade.pnl_percent || 0);
    const pnlClass = pnl >= 0 ? 'profit' : 'loss';
    const pnlSign = pnl >= 0 ? '+' : '';
    
    return `
      <div class="trade-card" style="animation-delay: ${index * 0.1}s">
        <div class="trade-header">
          <div class="trade-ticker">${trade.ticker}</div>
          <div class="trade-number">#${trade.trade_number}</div>
        </div>
        
        <div class="trade-details">
          <div class="trade-detail">
            <div class="trade-detail-label">Direction</div>
            <div class="trade-detail-value">${trade.direction}</div>
          </div>
          <div class="trade-detail">
            <div class="trade-detail-label">Position</div>
            <div class="trade-detail-value">${trade.position_size} shares</div>
          </div>
          <div class="trade-detail">
            <div class="trade-detail-label">Entry</div>
            <div class="trade-detail-value">$${parseFloat(trade.entry_price).toFixed(2)}</div>
          </div>
          <div class="trade-detail">
            <div class="trade-detail-label">Exit</div>
            <div class="trade-detail-value">$${parseFloat(trade.exit_price).toFixed(2)}</div>
          </div>
        </div>
        
        <div class="trade-pnl ${pnlClass}">
          ${pnlSign}$${Math.abs(pnl).toFixed(2)} (${pnlSign}${pnlPercent.toFixed(2)}%)
        </div>
        
        <div class="trade-footer">
          <div class="trade-date">${new Date(trade.entry_date).toLocaleDateString()}</div>
          <div class="trade-strategy">${trade.strategy || 'N/A'}</div>
        </div>
      </div>
    `;
  }
  
  /**
   * Update stats display
   * @param {Object} stats - Statistics object from trades index
   * @param {Object} analytics - Analytics data with percentage returns
   */
  updateStats(stats, analytics = null) {
    if (!stats || Object.keys(stats).length === 0) return;
    
    // Calculate portfolio value if accountManager is available
    let portfolioValue = 0;
    if (window.accountManager && window.accountManager.initialized) {
      portfolioValue = window.accountManager.calculatePortfolioValue(stats.total_pnl || 0);
    }
    
    // Get total return percentage from analytics
    let totalReturnPercent = 0;
    if (analytics && analytics.returns) {
      totalReturnPercent = analytics.returns.total_return_percent || 0;
    }
    
    // Update DOM
    const statElements = {
      'stat-portfolio-value': `$${portfolioValue.toFixed(2)}`,
      'stat-total-return': `${totalReturnPercent >= 0 ? '+' : ''}${totalReturnPercent.toFixed(2)}%`,
      'stat-total-trades': stats.total_trades || 0,
      'stat-win-rate': `${stats.win_rate || 0}%`,
      'stat-total-pnl': `$${(stats.total_pnl || 0).toFixed(2)}`,
      'stat-avg-pnl': `$${(stats.avg_pnl || 0).toFixed(2)}`
    };
    
    Object.entries(statElements).forEach(([id, value]) => {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = value;
        // Add positive/negative class for P&L
        if (id.includes('pnl')) {
          const totalPnL = stats.total_pnl || 0;
          element.classList.remove('positive', 'negative');
          element.classList.add(totalPnL >= 0 ? 'positive' : 'negative');
        }
        // Add positive/negative class for portfolio value
        if (id === 'stat-portfolio-value') {
          element.classList.remove('positive', 'negative');
          element.classList.add(portfolioValue >= 0 ? 'positive' : 'negative');
        }
        // Add positive/negative class for total return
        if (id === 'stat-total-return') {
          element.classList.remove('positive', 'negative');
          element.classList.add(totalReturnPercent >= 0 ? 'positive' : 'negative');
        }
      }
    });
  }
  
  /**
   * Set up trade form with auto-calculations
   */
  setupTradeForm() {
    const form = document.getElementById('trade-form');
    if (!form) return;
    
    // Auto-calculate fields
    const entryPrice = document.getElementById('entry_price');
    const exitPrice = document.getElementById('exit_price');
    const positionSize = document.getElementById('position_size');
    const direction = document.getElementById('direction');
    
    const calculateFields = [entryPrice, exitPrice, positionSize, direction];
    
    calculateFields.forEach(field => {
      if (field) {
        field.addEventListener('input', () => this.calculateTradeMetrics());
      }
    });
    
    // Entry/Exit date and time for time-in-trade calculation
    const entryDate = document.getElementById('entry_date');
    const entryTime = document.getElementById('entry_time');
    const exitDate = document.getElementById('exit_date');
    const exitTime = document.getElementById('exit_time');
    
    const timeFields = [entryDate, entryTime, exitDate, exitTime];
    timeFields.forEach(field => {
      if (field) {
        field.addEventListener('input', () => this.calculateTimeInTrade());
      }
    });
    
    // Stop loss and target for R:R calculation
    const stopLoss = document.getElementById('stop_loss');
    const targetPrice = document.getElementById('target_price');
    
    [stopLoss, targetPrice, entryPrice].forEach(field => {
      if (field) {
        field.addEventListener('input', () => this.calculateRiskReward());
      }
    });
    
    // File upload
    const fileInput = document.getElementById('screenshots');
    if (fileInput) {
      fileInput.addEventListener('change', (e) => this.handleFileUpload(e));
    }
    
    // Tag inputs
    this.setupTagInputs();
    
    // Form submission
    form.addEventListener('submit', (e) => this.handleFormSubmit(e));
  }
  
  /**
   * Setup tag input handlers
   */
  setupTagInputs() {
    const tagInputs = ['strategy_tags', 'setup_tags', 'session_tags', 'market_condition_tags'];
    
    tagInputs.forEach(inputId => {
      const input = document.getElementById(inputId);
      if (input) {
        // Initialize tag storage
        input.tagList = [];
        
        // Handle Enter key to add tags
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ',') {
            e.preventDefault();
            this.addTag(inputId);
          }
        });
        
        // Handle blur to add tag if text exists
        input.addEventListener('blur', () => {
          if (input.value.trim()) {
            this.addTag(inputId);
          }
        });
      }
    });
  }
  
  /**
   * Add a tag to the display
   * @param {string} inputId - ID of the tag input field
   */
  addTag(inputId) {
    const input = document.getElementById(inputId);
    const display = document.getElementById(`${inputId}_display`);
    
    if (!input || !display) return;
    
    const tagText = input.value.trim();
    if (!tagText) return;
    
    // Split by comma for multiple tags
    const tags = tagText.split(',').map(t => t.trim()).filter(t => t);
    
    tags.forEach(tag => {
      // Avoid duplicates
      if (input.tagList && !input.tagList.includes(tag)) {
        input.tagList.push(tag);
        
        // Create tag element
        const tagEl = document.createElement('div');
        tagEl.className = 'tag-item';
        tagEl.innerHTML = `
          <span>${tag}</span>
          <span class="tag-remove" data-tag="${tag}" data-input="${inputId}">×</span>
        `;
        
        // Add remove handler
        tagEl.querySelector('.tag-remove').addEventListener('click', (e) => {
          this.removeTag(inputId, tag);
        });
        
        display.appendChild(tagEl);
      }
    });
    
    // Clear input
    input.value = '';
  }
  
  /**
   * Remove a tag from the display
   * @param {string} inputId - ID of the tag input field
   * @param {string} tag - Tag to remove
   */
  removeTag(inputId, tag) {
    const input = document.getElementById(inputId);
    const display = document.getElementById(`${inputId}_display`);
    
    if (!input || !display) return;
    
    // Remove from list
    if (input.tagList) {
      const index = input.tagList.indexOf(tag);
      if (index > -1) {
        input.tagList.splice(index, 1);
      }
    }
    
    // Remove from display
    const tagElements = display.querySelectorAll('.tag-item');
    tagElements.forEach(el => {
      if (el.querySelector(`[data-tag="${tag}"]`)) {
        el.remove();
      }
    });
  }
  
  /**
   * Calculate trade P&L and percentage
   */
  calculateTradeMetrics() {
    const entryPrice = parseFloat(document.getElementById('entry_price')?.value) || 0;
    const exitPrice = parseFloat(document.getElementById('exit_price')?.value) || 0;
    const positionSize = parseInt(document.getElementById('position_size')?.value) || 0;
    const direction = document.getElementById('direction')?.value;
    
    if (!entryPrice || !exitPrice || !positionSize || !direction) return;
    
    let pnlUSD, pnlPercent;
    
    if (direction === 'LONG') {
      pnlUSD = (exitPrice - entryPrice) * positionSize;
      pnlPercent = ((exitPrice - entryPrice) / entryPrice) * 100;
    } else { // SHORT
      pnlUSD = (entryPrice - exitPrice) * positionSize;
      pnlPercent = ((entryPrice - exitPrice) / entryPrice) * 100;
    }
    
    // Display results
    const pnlUSDEl = document.getElementById('calc-pnl-usd');
    const pnlPercentEl = document.getElementById('calc-pnl-percent');
    
    if (pnlUSDEl) {
      pnlUSDEl.textContent = `$${pnlUSD.toFixed(2)}`;
      pnlUSDEl.className = pnlUSD >= 0 ? 'positive' : 'negative';
    }
    
    if (pnlPercentEl) {
      pnlPercentEl.textContent = `${pnlPercent >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%`;
      pnlPercentEl.className = pnlPercent >= 0 ? 'positive' : 'negative';
    }
  }
  
  /**
   * Calculate time in trade
   */
  calculateTimeInTrade() {
    const entryDate = document.getElementById('entry_date')?.value;
    const entryTime = document.getElementById('entry_time')?.value;
    const exitDate = document.getElementById('exit_date')?.value;
    const exitTime = document.getElementById('exit_time')?.value;
    
    if (!entryDate || !entryTime || !exitDate || !exitTime) return;
    
    const entryDateTime = new Date(`${entryDate}T${entryTime}`);
    const exitDateTime = new Date(`${exitDate}T${exitTime}`);
    
    const diffMs = exitDateTime - entryDateTime;
    const diffMins = Math.floor(diffMs / 60000);
    const hours = Math.floor(diffMins / 60);
    const minutes = diffMins % 60;
    
    const timeInTradeEl = document.getElementById('calc-time-in-trade');
    if (timeInTradeEl) {
      timeInTradeEl.textContent = `${hours}h ${minutes}m`;
    }
  }
  
  /**
   * Calculate risk-reward ratio
   */
  calculateRiskReward() {
    const entryPrice = parseFloat(document.getElementById('entry_price')?.value) || 0;
    const stopLoss = parseFloat(document.getElementById('stop_loss')?.value) || 0;
    const targetPrice = parseFloat(document.getElementById('target_price')?.value) || 0;
    
    if (!entryPrice || !stopLoss || !targetPrice) return;
    
    const risk = Math.abs(entryPrice - stopLoss);
    const reward = Math.abs(targetPrice - entryPrice);
    const ratio = risk > 0 ? (reward / risk).toFixed(2) : 0;
    
    const rrEl = document.getElementById('calc-risk-reward');
    if (rrEl) {
      rrEl.textContent = `1:${ratio}`;
    }
  }
  
  /**
   * Handle file upload for screenshots
   */
  handleFileUpload(event) {
    const files = Array.from(event.target.files);
    const preview = document.getElementById('file-preview');
    
    if (!preview) return;
    
    files.forEach(file => {
      if (!file.type.startsWith('image/')) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        this.uploadedImages.push({
          name: file.name,
          data: e.target.result,
          base64: e.target.result.split(',')[1]
        });
        
        // Add preview
        const previewItem = document.createElement('div');
        previewItem.className = 'file-preview-item';
        previewItem.innerHTML = `
          <img src="${e.target.result}" alt="${file.name}" class="file-preview-image">
          <button type="button" class="file-preview-remove" data-name="${file.name}">×</button>
        `;
        
        previewItem.querySelector('.file-preview-remove').addEventListener('click', () => {
          this.uploadedImages = this.uploadedImages.filter(img => img.name !== file.name);
          previewItem.remove();
        });
        
        preview.appendChild(previewItem);
      };
      
      reader.readAsDataURL(file);
    });
  }
  
  /**
   * Handle form submission
   */
  async handleFormSubmit(event) {
    event.preventDefault();
    
    // Check authentication
    if (!this.auth.isAuthenticated()) {
      showAuthPrompt();
      return;
    }
    
    const submitBtn = event.target.querySelector('button[type="submit"]');
    const originalText = submitBtn.textContent;
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="loading"></span> Submitting...';
    
    try {
      // Gather form data
      const formData = this.getFormData();
      
      // Calculate year-week number and format date
      const entryDate = new Date(formData.entry_date);
      const yearWeek = this.getYearWeekNumber(entryDate);
      const dateFormatted = this.formatDateForFilename(formData.entry_date);
      const tradeNum = formData.trade_number;
      
      // Generate file paths using new structure: index.directory/SFTi.Tradez/week.YYYY.WW/{MM:DD:YYYY.N}.md
      const weekFolder = `week.${yearWeek}`;
      const filename = `${dateFormatted}.${tradeNum}.md`;
      const tradePath = `index.directory/SFTi.Tradez/${weekFolder}/${filename}`;
      
      // Generate markdown content
      const markdown = this.generateTradeMarkdown(formData);
      
      // Upload images first to: index.directory/assets/sfti.tradez.assets/week.YYYY.WW/{MM:DD:YYYY.N}/
      if (this.uploadedImages.length > 0) {
        await this.uploadImages(weekFolder, dateFormatted, tradeNum);
      }
      
      // Upload trade markdown
      await this.auth.uploadFile(
        tradePath,
        btoa(unescape(encodeURIComponent(markdown))),
        `auto: new trade added ${dateFormatted}/${formData.ticker}`
      );
      
      // Show success message
      alert(`Trade #${tradeNum} submitted successfully!\nFile: ${tradePath}`);
      
      // Reset form
      event.target.reset();
      this.uploadedImages = [];
      document.getElementById('file-preview').innerHTML = '';
      
    } catch (error) {
      console.error('Submission error:', error);
      alert(`Failed to submit trade: ${error.message}`);
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = originalText;
    }
  }
  
  /**
   * Get form data as object
   * @returns {Object}
   */
  getFormData() {
    const form = document.getElementById('trade-form');
    const data = {};
    
    const fields = [
      'trade_number', 'ticker', 'entry_date', 'entry_time',
      'exit_date', 'exit_time', 'entry_price', 'exit_price',
      'position_size', 'direction', 'strategy', 'stop_loss',
      'target_price', 'broker', 'notes'
    ];
    
    fields.forEach(field => {
      const element = form.querySelector(`#${field}`);
      if (element) {
        data[field] = element.value;
      }
    });
    
    // Add tag data (v1.1 schema)
    const tagFields = ['strategy_tags', 'setup_tags', 'session_tags', 'market_condition_tags'];
    tagFields.forEach(tagField => {
      const input = document.getElementById(tagField);
      if (input && input.tagList && input.tagList.length > 0) {
        data[tagField] = input.tagList;
      }
    });
    
    // Add calculated values
    const entryPrice = parseFloat(data.entry_price);
    const exitPrice = parseFloat(data.exit_price);
    const positionSize = parseInt(data.position_size);
    const direction = data.direction;
    
    if (direction === 'LONG') {
      data.pnl_usd = ((exitPrice - entryPrice) * positionSize).toFixed(2);
      data.pnl_percent = (((exitPrice - entryPrice) / entryPrice) * 100).toFixed(2);
    } else {
      data.pnl_usd = ((entryPrice - exitPrice) * positionSize).toFixed(2);
      data.pnl_percent = (((entryPrice - exitPrice) / entryPrice) * 100).toFixed(2);
    }
    
    // Risk-reward ratio
    const risk = Math.abs(entryPrice - parseFloat(data.stop_loss));
    const reward = Math.abs(parseFloat(data.target_price) - entryPrice);
    data.risk_reward_ratio = risk > 0 ? (reward / risk).toFixed(2) : '0';
    
    return data;
  }
  
  /**
   * Generate markdown content for trade
   * @param {Object} data - Form data
   * @returns {string}
   */
  generateTradeMarkdown(data) {
    // Calculate paths for images
    const entryDate = new Date(data.entry_date);
    const yearWeek = this.getYearWeekNumber(entryDate);
    const weekFolder = `week.${yearWeek}`;
    const dateFormatted = this.formatDateForFilename(data.entry_date);
    
    const screenshots = this.uploadedImages.map(img => 
      `  - ../../assets/sfti.tradez.assets/${weekFolder}/${dateFormatted}.${data.trade_number}/${img.name}`
    ).join('\n');
    
    // Build YAML frontmatter with optional tags
    let frontmatter = `---
trade_number: ${data.trade_number}
ticker: ${data.ticker}
entry_date: ${data.entry_date}
entry_time: ${data.entry_time}
exit_date: ${data.exit_date}
exit_time: ${data.exit_time}
entry_price: ${data.entry_price}
exit_price: ${data.exit_price}
position_size: ${data.position_size}
direction: ${data.direction}
strategy: ${data.strategy}
stop_loss: ${data.stop_loss}
target_price: ${data.target_price}
risk_reward_ratio: ${data.risk_reward_ratio}
broker: ${data.broker}
pnl_usd: ${data.pnl_usd}
pnl_percent: ${data.pnl_percent}`;
    
    // Add tags if present (v1.1 schema)
    if (data.strategy_tags && data.strategy_tags.length > 0) {
      frontmatter += `\nstrategy_tags: [${data.strategy_tags.map(t => `"${t}"`).join(', ')}]`;
    }
    if (data.setup_tags && data.setup_tags.length > 0) {
      frontmatter += `\nsetup_tags: [${data.setup_tags.map(t => `"${t}"`).join(', ')}]`;
    }
    if (data.session_tags && data.session_tags.length > 0) {
      frontmatter += `\nsession_tags: [${data.session_tags.map(t => `"${t}"`).join(', ')}]`;
    }
    if (data.market_condition_tags && data.market_condition_tags.length > 0) {
      frontmatter += `\nmarket_condition_tags: [${data.market_condition_tags.map(t => `"${t}"`).join(', ')}]`;
    }
    
    frontmatter += `\nscreenshots:
${screenshots || '  - None'}
---`;
    
    return `${frontmatter}

# Trade #${data.trade_number} - ${data.ticker}

## Trade Details

- **Ticker**: ${data.ticker}
- **Direction**: ${data.direction}
- **Entry**: $${data.entry_price} on ${data.entry_date} at ${data.entry_time}
- **Exit**: $${data.exit_price} on ${data.exit_date} at ${data.exit_time}
- **Position Size**: ${data.position_size} shares
- **Strategy**: ${data.strategy}
- **Broker**: ${data.broker}

## Risk Management

- **Stop Loss**: $${data.stop_loss}
- **Target Price**: $${data.target_price}
- **Risk:Reward Ratio**: 1:${data.risk_reward_ratio}

## Results

- **P&L (USD)**: $${data.pnl_usd}
- **P&L (%)**: ${data.pnl_percent}%

## Notes

${data.notes || 'No additional notes.'}

## Screenshots

${this.uploadedImages.length > 0 ? this.uploadedImages.map(img => 
  `<img width="2048" height="1679" alt="image" src="../../assets/sfti.tradez.assets/${weekFolder}/${dateFormatted}.${data.trade_number}/${img.name}"/>`
).join('\n\n') : 'No screenshots uploaded.'}
`;
  }
  
  /**
   * Upload images to assets/sfti.tradez.assets/
   * @param {string} weekFolder - Week folder name (e.g., "week.2025.42")
   * @param {string} dateFormatted - Date in MM:DD:YYYY format
   * @param {string} tradeNum - Trade number
   */
  async uploadImages(weekFolder, dateFormatted, tradeNum) {
    const basePath = `index.directory/assets/sfti.tradez.assets/${weekFolder}/${dateFormatted}.${tradeNum}`;
    
    for (const image of this.uploadedImages) {
      const imagePath = `${basePath}/${image.name}`;
      await this.auth.uploadFile(
        imagePath,
        image.base64,
        `auto: add screenshot for ${dateFormatted}.${tradeNum}`
      );
    }
  }
}

// Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.tradingJournal = new TradingJournal();
});
