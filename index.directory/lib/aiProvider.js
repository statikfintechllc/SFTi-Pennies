/**
 * AI Provider Interface
 * Provides a provider-agnostic interface for AI-assisted summary generation
 */

/**
 * Base AI Provider Interface
 */
class AIProvider {
  constructor(config = {}) {
    this.config = config;
    this.enabled = config.enabled || false;
  }

  /**
   * Generate a summary using AI
   * @param {Object} options - Generation options
   * @param {string} options.period - 'month' or 'year'
   * @param {number} options.year - Year
   * @param {number} [options.month] - Month (for monthly summaries)
   * @param {Array} options.tradeFiles - Array of trade data
   * @param {Array} options.weeklySummaries - Array of weekly summary data
   * @param {Object} [options.generationOptions] - Additional generation options
   * @returns {Promise<Object>} Generated summary result
   */
  async generateSummary(options) {
    throw new Error('generateSummary must be implemented by provider');
  }

  /**
   * Check if provider is available and configured
   * @returns {Promise<boolean>} True if available
   */
  async isAvailable() {
    return this.enabled;
  }

  /**
   * Get provider name
   * @returns {string} Provider name
   */
  getName() {
    return 'base';
  }
}

/**
 * Mock AI Provider for Testing
 * Returns deterministic mock summaries
 */
class MockAIProvider extends AIProvider {
  constructor(config = {}) {
    super(config);
    this.delay = config.delay || 500; // Simulate API delay
  }

  async generateSummary(options) {
    const { period, year, month, tradeFiles, weeklySummaries, generationOptions } = options;

    // Simulate API delay
    await new Promise(resolve => setTimeout(resolve, this.delay));

    // Calculate aggregate stats from trade files and weekly summaries
    const stats = this.calculateStats(tradeFiles, weeklySummaries);

    // Generate mock summary
    const summary = this.generateMockSummary(period, year, month, stats, generationOptions);

    return {
      success: true,
      draftContent: summary,
      metadata: {
        provider: this.getName(),
        generatedAt: new Date().toISOString(),
        tradeCount: tradeFiles.length,
        weekCount: weeklySummaries.length,
        score: 0.85 // Mock confidence score
      }
    };
  }

  calculateStats(tradeFiles, weeklySummaries) {
    let totalPnl = 0;
    let totalTrades = 0;
    let winners = 0;
    let losers = 0;

    // Aggregate from trade files
    tradeFiles.forEach(trade => {
      const pnl = parseFloat(trade.pnl_usd || 0);
      totalPnl += pnl;
      totalTrades++;
      if (pnl > 0) winners++;
      else if (pnl < 0) losers++;
    });

    const winRate = totalTrades > 0 ? ((winners / totalTrades) * 100).toFixed(1) : 0;
    const avgPnl = totalTrades > 0 ? (totalPnl / totalTrades).toFixed(2) : 0;

    return {
      totalTrades,
      totalPnl: totalPnl.toFixed(2),
      winners,
      losers,
      winRate,
      avgPnl
    };
  }

  generateMockSummary(period, year, month, stats, options = {}) {
    const periodLabel = period === 'month' 
      ? `${new Date(year, month - 1).toLocaleString('default', { month: 'long' })} ${year}`
      : year;

    const includeAnalysis = options.includeAnalysis !== false;
    const includeRecommendations = options.includeRecommendations !== false;

    let summary = `# ${periodLabel} ${period === 'month' ? 'Monthly' : 'Yearly'} Summary

**Period**: ${period === 'month' ? `${year}-${String(month).padStart(2, '0')}` : year}

## Statistics

- **Total Trades**: ${stats.totalTrades}
- **Win Rate**: ${stats.winRate}%
- **Total P&L**: $${stats.totalPnl}
- **Average P&L per Trade**: $${stats.avgPnl}
- **Winning Trades**: ${stats.winners}
- **Losing Trades**: ${stats.losers}

`;

    if (includeAnalysis) {
      summary += `## AI-Generated Performance Analysis

### Highlights

${this.generateHighlights(stats)}

### Areas for Improvement

${this.generateImprovements(stats)}

### Key Patterns Identified

${this.generatePatterns(stats)}

`;
    }

    if (includeRecommendations) {
      summary += `## AI Recommendations for Next ${period === 'month' ? 'Month' : 'Year'}

${this.generateRecommendations(stats)}

`;
    }

    summary += `---

**Generated by AI**: ${new Date().toISOString()}
**Confidence Score**: 85%

*This is an AI-generated draft. Please review and edit as needed before publishing.*
`;

    return summary;
  }

  generateHighlights(stats) {
    if (parseFloat(stats.totalPnl) > 0) {
      return `- Achieved positive returns with a total P&L of $${stats.totalPnl}
- Maintained a win rate of ${stats.winRate}%, demonstrating consistent strategy execution
- Successfully completed ${stats.totalTrades} trades during the period`;
    } else {
      return `- Completed ${stats.totalTrades} trades with valuable learning opportunities
- Maintained disciplined risk management throughout the period
- Generated important data for strategy refinement`;
    }
  }

  generateImprovements(stats) {
    const improvements = [];
    
    if (parseFloat(stats.winRate) < 50) {
      improvements.push('- Focus on improving trade selection criteria to increase win rate');
    }
    if (parseFloat(stats.avgPnl) < 0) {
      improvements.push('- Review risk management to ensure losses are cut quickly');
    }
    if (stats.totalTrades < 10) {
      improvements.push('- Consider increasing trade frequency while maintaining quality setups');
    }

    return improvements.length > 0 
      ? improvements.join('\n')
      : '- Continue executing the current strategy while monitoring for optimization opportunities';
  }

  generatePatterns(stats) {
    return `- Trade execution shows consistent application of the established framework
- Risk-reward ratios suggest adherence to planned entry and exit strategies
- Performance metrics indicate opportunities for pattern recognition improvement`;
  }

  generateRecommendations(stats) {
    const recommendations = [];
    
    recommendations.push('1. Review all trades to identify repeating patterns in both winning and losing setups');
    recommendations.push('2. Focus on high-probability setups that align with the 7-Step Framework');
    recommendations.push('3. Maintain strict risk management with predetermined stop losses');
    
    if (parseFloat(stats.winRate) < 50) {
      recommendations.push('4. Consider reducing position sizes until win rate improves above 50%');
    } else {
      recommendations.push('4. Consider gradually scaling position sizes on proven setups');
    }
    
    recommendations.push('5. Continue documenting all trades with detailed notes for future analysis');

    return recommendations.join('\n');
  }

  async isAvailable() {
    return true; // Mock provider is always available
  }

  getName() {
    return 'mock';
  }
}

/**
 * OpenAI Provider (Optional)
 * Requires OpenAI API key
 */
class OpenAIProvider extends AIProvider {
  constructor(config = {}) {
    super(config);
    this.apiKey = config.apiKey || process.env.OPENAI_API_KEY;
    this.model = config.model || 'gpt-4';
    this.maxTokens = config.maxTokens || 2000;
  }

  async generateSummary(options) {
    if (!this.apiKey) {
      throw new Error('OpenAI API key not configured');
    }

    const { period, year, month, tradeFiles, weeklySummaries, generationOptions } = options;

    // Build prompt
    const prompt = this.buildPrompt(period, year, month, tradeFiles, weeklySummaries, generationOptions);

    try {
      // Call OpenAI API
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.apiKey}`
        },
        body: JSON.stringify({
          model: this.model,
          messages: [
            {
              role: 'system',
              content: 'You are an expert trading journal analyst helping traders improve their performance through detailed summary analysis.'
            },
            {
              role: 'user',
              content: prompt
            }
          ],
          max_tokens: this.maxTokens,
          temperature: 0.7
        })
      });

      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.statusText}`);
      }

      const data = await response.json();
      const content = data.choices[0].message.content;

      return {
        success: true,
        draftContent: content,
        metadata: {
          provider: this.getName(),
          generatedAt: new Date().toISOString(),
          tradeCount: tradeFiles.length,
          weekCount: weeklySummaries.length,
          model: this.model,
          usage: data.usage
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        metadata: {
          provider: this.getName(),
          generatedAt: new Date().toISOString()
        }
      };
    }
  }

  buildPrompt(period, year, month, tradeFiles, weeklySummaries, options) {
    const periodLabel = period === 'month'
      ? `${new Date(year, month - 1).toLocaleString('default', { month: 'long' })} ${year}`
      : year;

    let prompt = `Generate a comprehensive ${period}ly trading summary for ${periodLabel}.

TRADE DATA:
${JSON.stringify(tradeFiles, null, 2)}

WEEKLY SUMMARIES:
${JSON.stringify(weeklySummaries, null, 2)}

Please provide:
1. Summary statistics (total trades, win rate, P&L, etc.)
2. Performance analysis highlighting strengths and weaknesses
3. Key patterns identified in winning and losing trades
4. Specific recommendations for improvement
5. Goals for the next ${period}

Format the output as markdown following this structure:
- Title and period
- Statistics section
- Performance Analysis
- Key Lessons Learned
- Recommendations
- Next Period Goals

Focus on actionable insights and be specific in your recommendations.`;

    return prompt;
  }

  async isAvailable() {
    return this.enabled && !!this.apiKey;
  }

  getName() {
    return 'openai';
  }
}

/**
 * Provider Factory
 * Creates the appropriate AI provider based on configuration
 */
class AIProviderFactory {
  static create(providerName, config = {}) {
    const providers = {
      'mock': MockAIProvider,
      'openai': OpenAIProvider
    };

    const ProviderClass = providers[providerName] || MockAIProvider;
    return new ProviderClass(config);
  }

  static createFromEnv() {
    const enableAI = process.env.ENABLE_AI === 'true';
    const provider = process.env.AI_PROVIDER || 'mock';

    const config = {
      enabled: enableAI,
      apiKey: process.env.OPENAI_API_KEY,
      model: process.env.AI_MODEL || 'gpt-4',
      maxTokens: parseInt(process.env.AI_MAX_TOKENS || '2000', 10)
    };

    return AIProviderFactory.create(provider, config);
  }
}

// Export classes
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    AIProvider,
    MockAIProvider,
    OpenAIProvider,
    AIProviderFactory
  };
}
